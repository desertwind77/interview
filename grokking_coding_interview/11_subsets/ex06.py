#!/usr/bin/env python
# Given a word, write a function to generate all of its unique generalized
# abbreviations.
#
# A generalized abbreviation of a word can be generated by replacing each substring
# of the word with the count of characters in the substring. Take the example of “ab”
# which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings
# in the actual word by the count of characters, we get all the generalized
# abbreviations: “ab”, “1b”, “a1”, and “2”.
#
# Note: All contiguous characters should be considered one substring, e.g., we can’t
# take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous, we
# should consider them together as one substring to get an abbreviation “2”.

def replace( string ):
   prefix = ''
   count = 0
   for s in string:
      if s != '_':
         prefix += s
         continue
      count += 1

   if count != 0:
      prefix += str( count )

   return prefix

def abbreviate( str ):
   result = [ '' ]

   for s in str:
      tmp = []
      for r in result:
         tmp.append( r + '_' )
         tmp.append( replace( r ) + s )
      result = tmp

   result = [ replace( i ) for i in result ]

   return result

from collections import deque

class AbbreviatedWord:
   def __init__( self, str, start, count ):
      self.str = str
      self.start = start
      self.count = count

def generateGeneralizedAbbreviation( word ):
   wordLen = len( word )
   result = []
   queue = deque()
   queue.append( AbbreviatedWord( list(), 0, 0 ) )
   while queue:
      abWord = queue.popleft()
      if abWord.start == wordLen:
         if abWord.count != 0:
            abWord.str.append( str( abWord.count ) )
         result.append( ''.join( abWord.str ) )
      else:
         queue.append( AbbreviatedWord( list( abWord.str ), abWord.start + 1,
                                        abWord.count + 1 ) )

         if abWord.count != 0:
            abWord.str.append( str( abWord.count ) )

         newWord = list( abWord.str )
         newWord.append( word[ abWord.start ] )
         queue.append( AbbreviatedWord( newWord, abWord.start + 1, 0 ) )

   return result

def generateAbbreviationRecursive( word, abWord, start, count, result ):
   if start == len( word ):
      if count != 0:
         abWord.append( str( count ) )
      result.append( ''.join( abWord ) )
   else:
      generateAbbreviationRecursive(
            word, list( abWord ), start + 1, count + 1, result )

      if count != 0:
         abWord.append( str( count ) )
      newWord = list( abWord )
      newWord.append( word[ start ] )
      generateAbbreviationRecursive( word, newWord, start + 1, 0, result )

def generateGeneralizedAbbreviation2( word ):
   result = []
   generateAbbreviationRecursive( word, list(), 0, 0, result )
   return result

testCases = [
      {
         'input'  : 'BAT',
         'output' : [ 'BAT', 'BA1', 'B1T', 'B2', '1AT', '1A1', '2T', '3' ],
      },
      {
         'input'  : 'code',
         'output' : [ 'code', 'cod1', 'co1e', 'co2', 'c1de', 'c1d1',
                      'c2e', 'c3', '1ode', '1od1', '1o1e', '1o2',
                      '2de', '2d1', '3e', '4' ],
      },
]

for test in testCases:
   i = test[ 'input' ]
   o = sorted( test[ 'output' ] )
   assert( sorted( abbreviate( i ) ) == sorted( o ) )
   assert( sorted( generateGeneralizedAbbreviation( i ) ) == sorted( o ) )
   assert( sorted( generateGeneralizedAbbreviation2( i ) ) == sorted( o ) )
